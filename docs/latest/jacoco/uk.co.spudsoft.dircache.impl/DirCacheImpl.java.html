<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DirCacheImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Dir Cache</a> &gt; <a href="index.source.html" class="el_package">uk.co.spudsoft.dircache.impl</a> &gt; <span class="el_source">DirCacheImpl.java</span></div><h1>DirCacheImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2022 jtalbut
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package uk.co.spudsoft.dircache.impl;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.ClosedWatchServiceException;
import java.nio.file.FileSystems;
import static java.nio.file.FileVisitOption.FOLLOW_LINKS;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Pattern;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import uk.co.spudsoft.dircache.DirCache;
import uk.co.spudsoft.dircache.DirCacheTree;

/**
 * Default implementation of the {@link uk.co.spudsoft.dircache.DirCache} interface.
 *
 * @author jtalbut
 */
public class DirCacheImpl implements DirCache {

<span class="fc" id="L63">  private static final Logger logger = LoggerFactory.getLogger(DirCacheImpl.class);</span>

<span class="fc" id="L65">  private final Object readLock = new Object();</span>
<span class="fc" id="L66">  private final Object scanLock = new Object();</span>
<span class="fc" id="L67">  private final WatchService watcher = FileSystems.getDefault().newWatchService();</span>
<span class="fc" id="L68">  private final Map&lt;Path, WatchKey&gt; watches = new HashMap&lt;&gt;();</span>
<span class="fc" id="L69">  private final AtomicBoolean stopped = new AtomicBoolean(false);</span>
  private final Path rootPath;
  private final long stabilizationgLagMillis;
  private final Pattern ignore;
  private final Thread thread;
  private LocalDateTime lastWalkTime;
  private DirCacheTree.Directory rootNode;
  
  private Runnable callback;  

  /**
   * Constructor.
   * Create a dir cache of a given path, monitoring for any changes that occur.
   * 
   * Note that all the Nodes of a DirCache are immutable, whenever a change occurs the cache is rebuilt from the root.
   * As with most caches, the cache must be read more than written to make sense.
   * 
   * @param root The root of the directory cache, which should be a directory.
   * @param stabilizationgLag Time to wait after a file has changed before notifying the caller.
   * Note that the file structure is picked up by the DirCache immediately, it is only the callbacks that are delayed.
   * @param ignore Regular expression of files to ignore.
   * @throws FileNotFoundException if the root Path cannot be found, or if it is not a directory.
   * @throws IOException if attempts to walk the directory tree fail.
   */
<span class="fc" id="L93">  public DirCacheImpl(Path root, Duration stabilizationgLag, Pattern ignore) throws FileNotFoundException, IOException {</span>
<span class="fc" id="L94">    this.rootPath = root;</span>
<span class="fc" id="L95">    this.stabilizationgLagMillis = stabilizationgLag.toMillis();</span>
<span class="fc" id="L96">    this.ignore = ignore;</span>
<span class="fc" id="L97">    walk();</span>
<span class="fc" id="L98">    thread = new Thread(this::thread, &quot;DirCache: &quot; + root.toString());</span>
<span class="fc" id="L99">  }</span>

  @Override
  public DirCacheTree.Directory getRoot() {
<span class="fc" id="L103">    return rootNode;</span>
  }

  @Override
  public DirCacheImpl start() {
<span class="fc" id="L108">    thread.start();</span>
<span class="fc" id="L109">    return this;</span>
  }

  @Override
  public DirCacheImpl stop() {
<span class="fc" id="L114">    stopped.set(true);</span>
    try {
<span class="fc" id="L116">      watcher.close();</span>
<span class="nc" id="L117">    } catch (IOException ex) {</span>
<span class="nc" id="L118">      logger.info(&quot;Failed to close dir cache file watcher: &quot;, ex);</span>
<span class="fc" id="L119">    }</span>
<span class="fc" id="L120">    return this;</span>
  }

  @Override
  public void close() {
<span class="fc" id="L125">    stop();</span>
<span class="fc" id="L126">  }</span>

  @Override
  public DirCacheImpl setCallback(Runnable callback) {
<span class="fc" id="L130">    this.callback = callback;</span>
<span class="fc" id="L131">    return this;</span>
  }

  @Override
  public LocalDateTime getLastWalkTime() {
<span class="fc" id="L136">    return lastWalkTime;</span>
  }
  
  private void thread() {
<span class="fc" id="L140">    boolean active = false;</span>

<span class="fc bfc" id="L142" title="All 2 branches covered.">    while (!stopped.get()) {</span>
      // wait for key to be signaled
      WatchKey key;
      try {
<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (active) {</span>
<span class="fc" id="L147">          key = watcher.poll(stabilizationgLagMillis, TimeUnit.MILLISECONDS);</span>
        } else {
<span class="fc" id="L149">          key = watcher.take();</span>
<span class="fc" id="L150">          active = true;</span>
        }
<span class="fc" id="L152">      } catch (ClosedWatchServiceException x) {</span>
<span class="fc" id="L153">        stopped.set(true);</span>
<span class="fc" id="L154">        continue ;</span>
<span class="nc" id="L155">      } catch (InterruptedException x) {</span>
<span class="nc" id="L156">        continue ;</span>
<span class="fc" id="L157">      }</span>

<span class="fc" id="L159">      boolean wasDeleteOrTimeout = false;</span>
<span class="fc" id="L160">      boolean wasOnlyDeletes = true;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">      if (key == null) {</span>
<span class="fc" id="L162">        wasDeleteOrTimeout = true;</span>
      } else {
<span class="fc bfc" id="L164" title="All 2 branches covered.">        for (WatchEvent&lt;?&gt; event : key.pollEvents()) {</span>
          // Pick up deletes immediately, everything else can wait
<span class="fc bfc" id="L166" title="All 2 branches covered.">          if (event.kind() == ENTRY_DELETE) {</span>
<span class="fc" id="L167">            wasDeleteOrTimeout = true;</span>
          } else {
<span class="fc" id="L169">            wasOnlyDeletes = false;</span>
          }
<span class="fc" id="L171">        }</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (!key.reset()) {</span>
<span class="fc" id="L173">          watches.remove((Path) key.watchable());</span>
        }
      }
      
<span class="fc bfc" id="L177" title="All 2 branches covered.">      if (wasDeleteOrTimeout) {</span>
<span class="fc" id="L178">        walk();</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (wasOnlyDeletes) {</span>
<span class="fc" id="L180">          active = false;</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">          if (callback != null) {</span>
<span class="fc" id="L182">            callback.run();</span>
          }
        }
      }
<span class="fc" id="L186">    }</span>
<span class="fc" id="L187">  }</span>

  private static class PathAndNodeList {

    public final Path path;
    private final LocalDateTime lastModified;
    public final List&lt;DirCacheTree.Node&gt; nodeList;

<span class="fc" id="L195">    PathAndNodeList(Path path, LocalDateTime lastModified) {</span>
<span class="fc" id="L196">      this.path = path;</span>
<span class="fc" id="L197">      this.lastModified = lastModified;</span>
<span class="fc" id="L198">      this.nodeList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L199">    }</span>
    
    void sort() {
<span class="fc" id="L202">      nodeList.sort(DirCacheImpl::compareNodes);</span>
<span class="fc" id="L203">    }</span>
  }
  
  static int compareNodes(DirCacheTree.Node o1, DirCacheTree.Node o2) {
<span class="fc bfc" id="L207" title="All 2 branches covered.">    if (o1 == o2) {</span>
<span class="fc" id="L208">      return 0;</span>
    }
<span class="fc bfc" id="L210" title="All 4 branches covered.">    if (o1 instanceof DirCacheTree.Directory &amp;&amp; o2 instanceof DirCacheTree.File) {</span>
<span class="fc" id="L211">      return -1;</span>
<span class="fc bfc" id="L212" title="All 4 branches covered.">    } else if (o2 instanceof DirCacheTree.Directory &amp;&amp; o1 instanceof DirCacheTree.File) {</span>
<span class="fc" id="L213">      return 1;</span>
    }
<span class="fc bfc" id="L215" title="All 2 branches covered.">    if (o1 == null) {</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">      if (o2 != null) {</span>
<span class="fc" id="L217">        return -1;</span>
      } else {
<span class="nc" id="L219">        return 0;</span>
      }
<span class="fc bfc" id="L221" title="All 2 branches covered.">    } else if (o2 == null) {</span>
<span class="fc" id="L222">      return 1;</span>
    } 
<span class="fc" id="L224">    return o1.getName().compareTo(o2.getName());</span>
  }

<span class="fc" id="L227">  private class Visitor implements FileVisitor&lt;Path&gt; {</span>

<span class="fc" id="L229">    private final List&lt;Path&gt; dirsFound = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L230">    private final Stack&lt;PathAndNodeList&gt; dirStack = new Stack&lt;&gt;();</span>
    private DirCacheTree.Directory root;

    public DirCacheTree.Directory getRoot() {
<span class="fc" id="L234">      return root;</span>
    }

    public List&lt;Path&gt; getDirsFound() {
<span class="fc" id="L238">      return dirsFound;</span>
    }
    
    private LocalDateTime getLastModified(BasicFileAttributes attrs) {
<span class="fc" id="L242">      return LocalDateTime.ofInstant(attrs.lastModifiedTime().toInstant(), ZoneOffset.UTC);</span>
    }

    @Override
    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
<span class="fc bfc" id="L247" title="All 2 branches covered.">      if (ignore.matcher(dir.getFileName().toString()).matches()) {</span>
<span class="fc" id="L248">        logger.trace(&quot;preVisitDirectory({}, {}) - IGNORED&quot;, dir, attrs.lastModifiedTime());</span>
<span class="fc" id="L249">        return FileVisitResult.SKIP_SUBTREE;</span>
      } else {
<span class="fc" id="L251">        logger.trace(&quot;preVisitDirectory({}, {})&quot;, dir, attrs.lastModifiedTime());</span>
<span class="fc" id="L252">        dirStack.add(new PathAndNodeList(dir, getLastModified(attrs)));</span>
<span class="fc" id="L253">        dirsFound.add(dir);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (!watches.containsKey(dir)) {</span>
          try {
<span class="fc" id="L256">            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);</span>
<span class="fc" id="L257">            watches.put(dir, key);</span>
<span class="nc" id="L258">          } catch (IOException ex) {</span>
<span class="nc" id="L259">            logger.warn(&quot;Failed to configure path watch for {}: &quot;, dir, ex);</span>
<span class="fc" id="L260">          }</span>
        }
<span class="fc" id="L262">        return FileVisitResult.CONTINUE;</span>
      }
    }

    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
<span class="fc bfc" id="L268" title="All 2 branches covered.">      if (!ignore.matcher(file.getFileName().toString()).matches()) {</span>
<span class="fc" id="L269">        logger.trace(&quot;visitFile({}, {}) in {}&quot;, file, attrs.lastModifiedTime(), dirStack.peek());</span>
<span class="fc" id="L270">        PathAndNodeList parent = dirStack.peek();</span>
<span class="fc" id="L271">        DirCacheTree.File thisFile = new DirCacheTree.File(file, getLastModified(attrs), attrs.size());</span>
<span class="fc" id="L272">        parent.nodeList.add(thisFile);</span>
      }
<span class="fc" id="L274">      return FileVisitResult.CONTINUE;</span>
    }

    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
<span class="nc" id="L279">      logger.trace(&quot;visitFileFailed({}, {})&quot;, file, exc);</span>
<span class="nc" id="L280">      return FileVisitResult.CONTINUE;</span>
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
<span class="fc" id="L285">      logger.trace(&quot;postVisitDirectory({}, {})&quot;, dir, exc);</span>
<span class="fc" id="L286">      PathAndNodeList panl = dirStack.pop();</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">      assert (dir.equals(panl.path));</span>
<span class="fc" id="L288">      panl.sort();</span>
<span class="fc" id="L289">      DirCacheTree.Directory thisDir = new DirCacheTree.Directory(dir, panl.lastModified, panl.nodeList);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">      if (dirStack.isEmpty()) {</span>
<span class="fc" id="L291">        root = thisDir;</span>
      } else {
<span class="fc" id="L293">        PathAndNodeList parent = dirStack.peek();</span>
<span class="fc" id="L294">        parent.nodeList.add(thisDir);</span>
      }
<span class="fc" id="L296">      return FileVisitResult.CONTINUE;</span>
    }
  }

  @Override
  public void refresh() {
<span class="nc" id="L302">    walk();</span>
<span class="nc" id="L303">  }</span>
  
  private void walk() {
<span class="fc" id="L306">    Visitor visitor = new Visitor();</span>
<span class="fc" id="L307">    LocalDateTime walkTime = LocalDateTime.now();</span>
<span class="fc" id="L308">    logger.debug(&quot;Scanning file tree after change notification&quot;);</span>
<span class="fc" id="L309">    synchronized (scanLock) {</span>
      try {
<span class="fc" id="L311">        Files.walkFileTree(rootPath, EnumSet.of(FOLLOW_LINKS), Integer.MAX_VALUE, visitor);</span>
<span class="nc" id="L312">      } catch (Throwable ex) {</span>
<span class="nc" id="L313">        logger.warn(&quot;Failed to update dir cache of {}: &quot;, rootPath, ex);</span>
<span class="nc" id="L314">        return ;</span>
<span class="fc" id="L315">      }</span>
      
<span class="fc" id="L317">      synchronized (readLock) {</span>
<span class="fc" id="L318">        this.rootNode = visitor.getRoot();</span>
<span class="fc" id="L319">        this.lastWalkTime = walkTime;</span>
<span class="fc" id="L320">      }</span>
<span class="fc" id="L321">      Set&lt;Path&gt; dirsFound = new HashSet&lt;&gt;(visitor.getDirsFound());</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">      for (Iterator&lt;Entry&lt;Path, WatchKey&gt;&gt; iter = watches.entrySet().iterator(); iter.hasNext();) {</span>
<span class="fc" id="L323">        Entry&lt;Path, WatchKey&gt; watching = iter.next();</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (!dirsFound.contains(watching.getKey())) {</span>
<span class="nc" id="L325">          logger.trace(&quot;Path {} no longer exists and is being removed from watches&quot;, watching.getKey());</span>
<span class="nc" id="L326">          iter.remove();</span>
        }
<span class="fc" id="L328">      }</span>
<span class="fc" id="L329">    }</span>
<span class="fc" id="L330">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>