<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DirCacheImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Dir Cache</a> &gt; <a href="index.source.html" class="el_package">uk.co.spudsoft.dircache.impl</a> &gt; <span class="el_source">DirCacheImpl.java</span></div><h1>DirCacheImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2022 jtalbut
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package uk.co.spudsoft.dircache.impl;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.ClosedWatchServiceException;
import java.nio.file.FileSystems;
import static java.nio.file.FileVisitOption.FOLLOW_LINKS;
import java.nio.file.FileVisitResult;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.Path;
import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Pattern;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import uk.co.spudsoft.dircache.DirCache;
import uk.co.spudsoft.dircache.DirCacheTree;

/**
 * Default implementation of the {@link uk.co.spudsoft.dircache.DirCache} interface.
 *
 * @author jtalbut
 */
public class DirCacheImpl implements DirCache {

<span class="fc" id="L63">  private static final Logger logger = LoggerFactory.getLogger(DirCacheImpl.class);</span>

<span class="fc" id="L65">  private final Object readLock = new Object();</span>
<span class="fc" id="L66">  private final Object scanLock = new Object();</span>
<span class="fc" id="L67">  private final Map&lt;Path, WatchKey&gt; watches = new HashMap&lt;&gt;();</span>
<span class="fc" id="L68">  private final AtomicBoolean stopped = new AtomicBoolean(false);</span>
  private final Path rootPath;
  private final long stabilizationgLagMillis;
  private final Pattern ignore;
  private Thread thread;
  private WatchService watcher;
  private LocalDateTime lastWalkTime;
  private DirCacheTree.Directory rootNode;
  
  private Runnable callback;  

  /**
   * Constructor.
   * Create a dir cache of a given path, monitoring for any changes that occur.
   * 
   * Note that all the Nodes of a DirCache are immutable, whenever a change occurs the cache is rebuilt from the root.
   * As with most caches, the cache must be read more than written to make sense.
   * 
   * @param root The root of the directory cache, which should be a directory.
   * @param stabilizationgLag Time to wait after a file has changed before notifying the caller.
   * Note that the file structure is picked up by the DirCache immediately, it is only the callbacks that are delayed.
   * @param ignore Regular expression of files to ignore.
   * @throws FileNotFoundException if the root Path cannot be found, or if it is not a directory.
   * @throws IOException if attempts to walk the directory tree fail.
   */
<span class="fc" id="L93">  public DirCacheImpl(Path root, Duration stabilizationgLag, Pattern ignore) throws FileNotFoundException, IOException {</span>
<span class="fc" id="L94">    this.rootPath = root;</span>
<span class="fc" id="L95">    this.stabilizationgLagMillis = stabilizationgLag.toMillis();</span>
<span class="fc" id="L96">    this.ignore = ignore;</span>
<span class="fc" id="L97">  }</span>

  @Override
  public DirCacheTree.Directory getRoot() {
<span class="fc" id="L101">    return rootNode;</span>
  }

  @Override
  public DirCacheImpl start() throws IOException {
<span class="fc" id="L106">    logger.info(&quot;Starting DirCache of {}&quot;, rootPath);</span>
<span class="fc" id="L107">    stopped.set(false);</span>
<span class="fc" id="L108">    watcher = FileSystems.getDefault().newWatchService();</span>
<span class="fc" id="L109">    walk();</span>
<span class="fc" id="L110">    thread = new Thread(this::thread, &quot;DirCache: &quot; + rootPath.toString());    </span>
<span class="fc" id="L111">    thread.start();</span>
<span class="fc" id="L112">    return this;</span>
  }

  @Override
  public DirCacheImpl stop() {
<span class="fc" id="L117">    stopped.set(true);</span>
    try {
<span class="fc" id="L119">      watcher.close();</span>
<span class="nc" id="L120">    } catch (IOException ex) {</span>
<span class="nc" id="L121">      logger.info(&quot;Failed to close dir cache file watcher: &quot;, ex);</span>
<span class="fc" id="L122">    }</span>
    try {
<span class="fc" id="L124">      thread.join();</span>
<span class="nc" id="L125">    } catch (InterruptedException ex) {</span>
<span class="nc" id="L126">      logger.info(&quot;Interrupted whilst waiting for thread to stop&quot;);</span>
<span class="fc" id="L127">    }</span>
<span class="fc" id="L128">    watcher = null;</span>
<span class="fc" id="L129">    watches.clear();</span>
<span class="fc" id="L130">    return this;</span>
  }

  @Override
  public void close() {
<span class="fc" id="L135">    stop();</span>
<span class="fc" id="L136">  }</span>

  @Override
  public DirCacheImpl setCallback(Runnable callback) {
<span class="fc" id="L140">    this.callback = callback;</span>
<span class="fc" id="L141">    return this;</span>
  }

  @Override
  public LocalDateTime getLastWalkTime() {
<span class="fc" id="L146">    return lastWalkTime;</span>
  }
  
  private void thread() {
<span class="fc" id="L150">    boolean active = false;</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">    while (!stopped.get()) {</span>
      // wait for key to be signaled
      WatchKey key;
      try {
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (active) {</span>
<span class="fc" id="L157">          key = watcher.poll(stabilizationgLagMillis, TimeUnit.MILLISECONDS);</span>
        } else {
<span class="fc" id="L159">          key = watcher.take();</span>
<span class="fc" id="L160">          active = true;</span>
        }
<span class="fc" id="L162">      } catch (ClosedWatchServiceException x) {</span>
<span class="fc" id="L163">        stopped.set(true);</span>
<span class="fc" id="L164">        continue ;</span>
<span class="nc" id="L165">      } catch (InterruptedException x) {</span>
<span class="nc" id="L166">        continue ;</span>
<span class="fc" id="L167">      }</span>

<span class="fc" id="L169">      boolean wasDeleteOrTimeout = false;</span>
<span class="fc" id="L170">      boolean wasOnlyDeletes = true;</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">      if (key == null) {</span>
<span class="fc" id="L172">        wasDeleteOrTimeout = true;</span>
      } else {
<span class="fc bfc" id="L174" title="All 2 branches covered.">        for (WatchEvent&lt;?&gt; event : key.pollEvents()) {</span>
          // Pick up deletes immediately, everything else can wait
<span class="fc bfc" id="L176" title="All 2 branches covered.">          if (event.kind() == ENTRY_DELETE) {</span>
<span class="fc" id="L177">            wasDeleteOrTimeout = true;</span>
          } else {
<span class="fc" id="L179">            wasOnlyDeletes = false;</span>
          }
<span class="fc" id="L181">        }</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (!key.reset()) {</span>
<span class="fc" id="L183">          watches.remove((Path) key.watchable());</span>
        }
      }
      
<span class="fc bfc" id="L187" title="All 2 branches covered.">      if (wasDeleteOrTimeout) {</span>
<span class="fc" id="L188">        walk();</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (wasOnlyDeletes) {</span>
<span class="fc" id="L190">          active = false;</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">          if (callback != null) {</span>
<span class="fc" id="L192">            callback.run();</span>
          }
        }
      }
<span class="fc" id="L196">    }</span>
<span class="fc" id="L197">  }</span>

  private static class PathAndNodeList {

    public final Path path;
    private final LocalDateTime lastModified;
    public final List&lt;DirCacheTree.Node&gt; nodeList;

<span class="fc" id="L205">    PathAndNodeList(Path path, LocalDateTime lastModified) {</span>
<span class="fc" id="L206">      this.path = path;</span>
<span class="fc" id="L207">      this.lastModified = lastModified;</span>
<span class="fc" id="L208">      this.nodeList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L209">    }</span>
    
    void sort() {
<span class="fc" id="L212">      nodeList.sort(DirCacheImpl::compareNodes);</span>
<span class="fc" id="L213">    }</span>
  }
  
  static int compareNodes(DirCacheTree.Node o1, DirCacheTree.Node o2) {
<span class="fc bfc" id="L217" title="All 2 branches covered.">    if (o1 == o2) {</span>
<span class="fc" id="L218">      return 0;</span>
    }
<span class="fc bfc" id="L220" title="All 4 branches covered.">    if (o1 instanceof DirCacheTree.Directory &amp;&amp; o2 instanceof DirCacheTree.File) {</span>
<span class="fc" id="L221">      return -1;</span>
<span class="fc bfc" id="L222" title="All 4 branches covered.">    } else if (o2 instanceof DirCacheTree.Directory &amp;&amp; o1 instanceof DirCacheTree.File) {</span>
<span class="fc" id="L223">      return 1;</span>
    }
<span class="fc bfc" id="L225" title="All 2 branches covered.">    if (o1 == null) {</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">      if (o2 != null) {</span>
<span class="fc" id="L227">        return -1;</span>
      } else {
<span class="nc" id="L229">        return 0;</span>
      }
<span class="fc bfc" id="L231" title="All 2 branches covered.">    } else if (o2 == null) {</span>
<span class="fc" id="L232">      return 1;</span>
    } 
<span class="fc" id="L234">    return o1.getName().compareTo(o2.getName());</span>
  }

<span class="fc" id="L237">  private class Visitor implements FileVisitor&lt;Path&gt; {</span>

<span class="fc" id="L239">    private final List&lt;Path&gt; dirsFound = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L240">    private final Stack&lt;PathAndNodeList&gt; dirStack = new Stack&lt;&gt;();</span>
    private DirCacheTree.Directory root;

    public DirCacheTree.Directory getRoot() {
<span class="fc" id="L244">      return root;</span>
    }

    public List&lt;Path&gt; getDirsFound() {
<span class="fc" id="L248">      return dirsFound;</span>
    }
    
    private LocalDateTime getLastModified(BasicFileAttributes attrs) {
<span class="fc" id="L252">      return LocalDateTime.ofInstant(attrs.lastModifiedTime().toInstant(), ZoneOffset.UTC);</span>
    }

    @Override
    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
<span class="fc bfc" id="L257" title="All 2 branches covered.">      if (ignore.matcher(dir.getFileName().toString()).matches()) {</span>
<span class="fc" id="L258">        logger.trace(&quot;preVisitDirectory({}, {}) - IGNORED&quot;, dir, attrs.lastModifiedTime());</span>
<span class="fc" id="L259">        return FileVisitResult.SKIP_SUBTREE;</span>
      } else {
<span class="fc" id="L261">        logger.trace(&quot;preVisitDirectory({}, {})&quot;, dir, attrs.lastModifiedTime());</span>
<span class="fc" id="L262">        dirStack.add(new PathAndNodeList(dir, getLastModified(attrs)));</span>
<span class="fc" id="L263">        dirsFound.add(dir);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        if (!watches.containsKey(dir)) {</span>
          try {
<span class="fc" id="L266">            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);</span>
<span class="fc" id="L267">            watches.put(dir, key);</span>
<span class="nc" id="L268">          } catch (IOException ex) {</span>
<span class="nc" id="L269">            logger.warn(&quot;Failed to configure path watch for {}: &quot;, dir, ex);</span>
<span class="fc" id="L270">          }</span>
        }
<span class="fc" id="L272">        return FileVisitResult.CONTINUE;</span>
      }
    }

    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
<span class="fc bfc" id="L278" title="All 2 branches covered.">      if (!ignore.matcher(file.getFileName().toString()).matches()) {</span>
<span class="fc" id="L279">        logger.trace(&quot;visitFile({}, {}) in {}&quot;, file, attrs.lastModifiedTime(), dirStack.peek());</span>
<span class="fc" id="L280">        PathAndNodeList parent = dirStack.peek();</span>
<span class="fc" id="L281">        DirCacheTree.File thisFile = new DirCacheTree.File(file, getLastModified(attrs), attrs.size());</span>
<span class="fc" id="L282">        parent.nodeList.add(thisFile);</span>
      }
<span class="fc" id="L284">      return FileVisitResult.CONTINUE;</span>
    }

    @Override
    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
<span class="nc" id="L289">      logger.trace(&quot;visitFileFailed({}, {})&quot;, file, exc);</span>
<span class="nc" id="L290">      return FileVisitResult.CONTINUE;</span>
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
<span class="fc" id="L295">      logger.trace(&quot;postVisitDirectory({}, {})&quot;, dir, exc);</span>
<span class="fc" id="L296">      PathAndNodeList panl = dirStack.pop();</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">      assert (dir.equals(panl.path));</span>
<span class="fc" id="L298">      panl.sort();</span>
<span class="fc" id="L299">      DirCacheTree.Directory thisDir = new DirCacheTree.Directory(dir, panl.lastModified, panl.nodeList);</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">      if (dirStack.isEmpty()) {</span>
<span class="fc" id="L301">        root = thisDir;</span>
      } else {
<span class="fc" id="L303">        PathAndNodeList parent = dirStack.peek();</span>
<span class="fc" id="L304">        parent.nodeList.add(thisDir);</span>
      }
<span class="fc" id="L306">      return FileVisitResult.CONTINUE;</span>
    }
  }

  @Override
  public void refresh() {
<span class="nc" id="L312">    walk();</span>
<span class="nc" id="L313">  }</span>
  
  private void walk() {
<span class="fc" id="L316">    Visitor visitor = new Visitor();</span>
<span class="fc" id="L317">    LocalDateTime walkTime = LocalDateTime.now();</span>
<span class="fc" id="L318">    logger.debug(&quot;Scanning file tree after change notification&quot;);</span>
<span class="fc" id="L319">    synchronized (scanLock) {</span>
      try {
<span class="fc" id="L321">        Files.walkFileTree(rootPath, EnumSet.of(FOLLOW_LINKS), Integer.MAX_VALUE, visitor);</span>
<span class="nc" id="L322">      } catch (Throwable ex) {</span>
<span class="nc" id="L323">        logger.warn(&quot;Failed to update dir cache of {}: &quot;, rootPath, ex);</span>
<span class="nc" id="L324">        return ;</span>
<span class="fc" id="L325">      }</span>
      
<span class="fc" id="L327">      synchronized (readLock) {</span>
<span class="fc" id="L328">        this.rootNode = visitor.getRoot();</span>
<span class="fc" id="L329">        this.lastWalkTime = walkTime;</span>
<span class="fc" id="L330">      }</span>
<span class="fc" id="L331">      Set&lt;Path&gt; dirsFound = new HashSet&lt;&gt;(visitor.getDirsFound());</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">      for (Iterator&lt;Entry&lt;Path, WatchKey&gt;&gt; iter = watches.entrySet().iterator(); iter.hasNext();) {</span>
<span class="fc" id="L333">        Entry&lt;Path, WatchKey&gt; watching = iter.next();</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (!dirsFound.contains(watching.getKey())) {</span>
<span class="fc" id="L335">          logger.trace(&quot;Path {} no longer exists and is being removed from watches&quot;, watching.getKey());</span>
<span class="fc" id="L336">          iter.remove();</span>
        }
<span class="fc" id="L338">      }</span>
<span class="fc" id="L339">    }</span>
<span class="fc" id="L340">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>